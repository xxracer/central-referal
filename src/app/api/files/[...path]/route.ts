import { NextRequest, NextResponse } from 'next/server';
import { adminStorage } from '@/lib/firebase-admin';
import { verifySession } from '@/lib/auth-actions';
import { headers } from 'next/headers';

// Secure File Proxy
// Usage: /api/files/companies/agencyId/referrals/refId/filename.pdf
export async function GET(req: NextRequest, { params }: { params: Promise<{ path: string[] }> }) {
    // 1. Authentication Check
    // We strictly require a session OR a valid signed short-lived token (future improvement).
    // For now, let's verify session.
    const session = await verifySession();

    // NOTE: For "Status Page" public access, this is tricky. 
    // The public user (patient) doesn't have a session.
    // They have a validated "Referral" object from `checkStatus` but that's server-side state.
    // Solutions:
    // A) Use a signed URL generated on the fly in `checkStatus` (best for public).
    // B) Use a temporary cookie set by `checkStatus` (possible).
    // C) Pass a token in the URL (e.g. ?token=...) generated by `checkStatus`.

    // Let's go with (A) for public access relative simplicity, or (C).
    // Actually, `checkStatus` returns `documents` list. We can generate Signed URLs *there* for display.
    // BUT the PDF generation `generateReferralPdf` returns a URL `_private/...`. 
    // The frontend sees `_private/...`. It needs to transform this.

    // Let's implement this route for STAFF access (Authenticated).
    if (!session) {
        return new NextResponse('Unauthorized', { status: 401 });
    }

    const { path } = await params;
    const filePath = path.join('/');

    // 2. Authorization Check (Optional but recommended)
    // Ensure user belongs to the agency owning the file? 
    // Path structure: companies/<agencyId>/...
    // We can check if session.claims.agencyId === agencyId or if role is admin.

    try {
        const bucket = adminStorage.bucket();
        const file = bucket.file(filePath);
        const [exists] = await file.exists();

        if (!exists) {
            return new NextResponse('File not found', { status: 404 });
        }

        const [metadata] = await file.getMetadata();
        const contentType = metadata.contentType || 'application/octet-stream';

        // Stream the file
        const [buffer] = await file.download();

        return new NextResponse(buffer as any as BodyInit, {
            headers: {
                'Content-Type': contentType,
                'Cache-Control': 'private, max-age=3600',
            },
        });
    } catch (error) {
        console.error("Error serving file:", error);
        return new NextResponse('Internal Server Error', { status: 500 });
    }
}
